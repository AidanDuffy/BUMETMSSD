Aidan Duffy
Boston University
METCS 526

Module 4:
	-CHAPTER 9 (Priority Queues):
		-
	-CHAPTER 10 (Maps & Hash Tables, skip 10.4):
		-

Module 3:
	-CHAPTER 7 (Lists):
		-The List ADT:
			-Methods:
				-size,isEmpty,get(i) where i is the index, set(i,e) sets index i to val e, add(i, e) inserts element e into list so it is at index i, remove(i)
		-Array Lists:
			-an array implementation of a list
			-add and remove need for loops here to shift all elements in the array after being added/removed
			-O(1) for size, isEmpty, get, set
			-O(N) for add and remove
			-Dynamic Arrays:
				-these are used to provide the sense that the arraylist has no size constraint
				-if array A reaches capacity, allocate a larger array B, usually with double the capacity and store all the old A data in B
				-doubling is expensive, but the return of being able to add an additional n elements is very rewarding
					-use amortization, a sequence of push operations on this dynamic array is quite efficient since add, get, set all should work in O(1) time if there is space, so O(n) on capacities when we need to double
					-need to resize geometrically not arithmetically, if we use a fixed size increase instead of doubling, the performance is much worse w/ a big-Omega of n^2
					-also, with geomtric, the final capacity will be proportional to the number of elements in the end, the data structure will use O(n) memory
		-Positional Lists:
			-defining an ADT for a list that int indeces are not perfect for, have a linked list in mind while creating the ADT
			-We need to define an abstract data type called position, supporting the getElement() method, which returns the elem at this position
				-a position acts as a marker within a broader positional list
				-position p which is associated with element e in list L does not change, even if index of e changes in L due to insertions or deletions elsewhere in the list, nor does p change if we replace element e stored at p with another element
			-ADT methods:
				-first()
				-last()
				-before(p) returns position of list L before position p
				-after(p)
				-isEmpty()
				-size()
				-the methods return associate positions, not elements
			-skipping the rest
		-Iterators:
			-is a software design pattern that abstracts the process of scanning through a sequence of elements, one at a time
			-has hasNext() and next() methods
				-while(iter.hasNext()) is very common
			-remove() removes from the collection the element returned by the most recent call to next()
			-iterator() returns an iterator of the elements in the collection
				-Iterator<Type> iter = collection.iterator();
		-Java Collections Framework:
			-List Iterators in Java:
				-we have a list "cursor" that stores the index of which node is returned by next()
				-ListIterator has:
					-add(e), hasNext(),hasPrevious(), previous(),next(),nextIndex(),previousIndex(), previous(), next(), nextIndex(), previousIndex(), remove(), set(e) (replaces element returned by the most recent call to the next or previous operation with e)
			-List-Based Algos in the Java Collections Framework:
				-copy(Ldest, Lsrc) copies all elements of Lsrc list into indecies of Ldest list
				-disjoint(C,D) returns T/F indicating whether the collections C&D are disjoint
				-fill(L,e) replaces each element of the list L with element e
				-frequency(C,e) returns number of elements in the collection C that = e
				-max(C), min(C)
				-replaceAll(L,e,f) replaces each element in L that equal e to f
				-reverse(L)
				-rotate(L,d) rotates elements in list L by distance d in a circular fashion
				-shuffle(L) pseudorandomly permutes the ordering of the elements in list L
				-sort(L)
				-swap(L,i,j) swaps elements at indecies i and j of list L
				-toArray() returns an array of elements of type Object containing all the elements in this collection 
				-toArray(A) returns an array of elements of the same element type as A containing all the elements in this collection
				-asList(A) reutnrs list representation of the array A, with the same element type as the elements of A
	-CHAPTER 8 (Trees):
		-General Trees:
			-important non linear data structure
			-a tree is an abstract data type that stores elements hierarchically
			-excluding the root, each element has a parent element or 0+ children elements
			-we formally define a tree T as a set of nodes storing elements s.t. the ndoes have a parent-child relationship that satisifies the following properties:
				-if T is nonempty, it has a special node called the root of T that has no parent
				-each node v of T different from the root has unique parent node w; every node with parent w is a child w
			-the above defintion allows for empty trees without root node r
			-nodes w/ same parent are siblings
			-v is an external node if it has no children, internal if it has one or more children
				-external are aka leaves
			-node u is an ancestor of node v if u = v or u is an ancestor of the parent of v
			-node v is a descendant of node u if u is an ancestor of v
			-the subtree of T rooted at node v is the tree consisting of all the descendants of v in T
			-an edge of tree T is a pair of nodes (u,v) s.t. u is the parent of v or vice versa
			-a path of T is a sequence of nodes s.t. any two consecutive nodes in the sequence form an edge
			-a tree is ordered if there is a meaningful linear order among the children of each node; that is, we purposefull indetify the children of a node as being the frist, second, third, etc
			-Tree ADT:
				-accessor methods: root(), parent(p), children(p) returns an iterable collection of all children of node p, numChildren(p)
				-query methods: isInternal(p), isExternal(p), isRoot(p)
				-general: size, isEmpty, iterator, positions
			-depth of a node is the number of ancestors of node, other than that node itself
			-the depth of p can be recursively defined:
				-if p is the root, then the depth of p is 0
				-otherwise, the depth is one plus the depth of the parent of p
			-the height of a tree is equal to the max of the depths, formally:
				-if p is a leaf, then the height of p is 0,
				-otherwise the height of p is one more than the maximum of the heights of p's children
			-Propositions:
				-height of the root of a nonempty tree T, according to the recursive dewfintion, equals the maximum depth among all leaves of tree T
				-let T be a tree w/ n positions, and let cp denote the number of children of node p of T, then summing over the nodes of T, summation sub p of cp = n-1
					-each node of T, w/ exception of the root, is a child of another node, and thus contributes one unit to the above sum
		-Binary Trees:
			-Properties:
				-every node has AT MOST two children
				-each child node is albeled as being either the left or right child
				-a left child precedes a right child in the order of children of a node
				-it is proper/full if each node has either 0 or 2 children
			-ADT:
				-left(p) returns node of the left child of p
				-right(p)
				-sibling(p)
			-Other Properties:
				-level 0 is root, increasing by 1, each level has at most 2^l nodes where l is the level
				-let T be nonempty binary tree, let n, nE, nI, and h denote number of nodes, number of external nodes, internal nodes, and height:
					-h+1 <= n <= 2^(h+1) -1
					-1 <= nE <= 2^h
					-h <= nI <= 2^h - 1
					-log(n+1) - 1 <= h <= n-1
				-if T is proper:
					-2h+1 <= n <= 2^(h+1) - 1
					-h+1 <= nE <= 2^h
					-h <= nI <= 2^h - 1
					-log(n+1) - 1 <= h <= (n-1)/2
					-nE = nI + 1
		-Implementing Trees:
			-Linked Structure for Binary Trees:
				-linked structure is a natural way of thinking about a tree, with nodes that store pointers to its children and its parent as well as its element
				-methods:
					-addRoot(e), addLeft(p,e), addRight(p,e), set(p,e), attach(p,T1,T2) attaches the internal structure of trees T1 and T2 as the left and right subtrees of leaf position p and resets T1 and T2 to empty trees, and remove(p)
				-check textbook for actual implementation
				-Runtimes:
					-O(1) for size, isEmpty,root,parent,left,right,sibling,children,numChildren, isInternal, isExternal, isRoot, addRoot, addLeft, addRight, set, attach, remove
					-O(dp + 1) for depth(p) where dp is depth
					-O(n) for height
			-Array Based Representation of a binary tree:
				-for every node p of tree T, let f(p) be the int defined as:
					-if p is the root of T, then f(p) = 0
					-if p is the left child of node q, then f(p) = 2f(q) + 1
					-if p is the right child of node q, then f(p) = 2f(q) + 2
				-the numbering function f is known as level numbering of the nodes in a binary Tree T, for it numbers the nodes on each level of T in increasing order from left to right
					-so the left child of the root's left child would be index 3 in the array if root is index 0
		-Tree Traversal Algos:
			- a traversla of a tree T is a systematic way of visiting all the nodes of T
			-Pre- and Postorder Traversals:
				-preorder algo:
					-perform the visit action for node p, then for each child do preorder(child)
					-so node, left subtree, right subtree
				-postorder algo:
					-perform visit for each child postorder(child) then perform visit action for node p
					-so left subtree,right subtree, then node/root
				-always in O(n) run time
			-Breadth First Traversal:
				-traverse left to right level by level
					-so if the tree is array implemented, just check each index in order
				-BFS algo:
					-initialize queue Q to contain root()
					-while Q not empty do:
						-p=Q.dequeue()
						-perform visit for node p
						-for each child:
							-Q.enqueue(child)
			-Inorder Traversal:
				-visit a node b/w recursive traverals of its left and right subtrees
				-algo:
					-if p has left child lc, then:
						-inorder(lc)
					-visit node p
					-if p has right child rc. then:
						-inorder(rc)
					-so its left subtree, root, right subtree
				-BST for S is a proper BT T s.t. for each internal node p of T:
					-Node n stores an element of S, denoted as e(p)
					-elements stored in left subtree of p are less than e(p)
					-"                  right                 greater       "		
Module 2:
	-CHAPTER 4 (Algo Analysis):
		-The Seven Functions Used in this Book:
			-Constant function, so it always runs in the same amount of time, regardless of input size
			-Logarithm Function, runs in log(n) time, usually log base 2
			-Linear function, runs in n time, ie comparing some num to each element of array sized n
			-N-Log-N Function, runs in n*log(n) time
			-Quadratic, runs in x^2 time, often pops up with nested loops
				-if the first iteration of the loop uses 1 op, the second uses 2 ops, up to n operations, then that happens n times
			-Cubic/Other polynomials runs in n^3 or n^a time, for polys, just use the biggest power for the big-Oh notation
			-Exponential function runs in a^n time, where input size is the power
		-Asymptotic Analysis:
			-Big-Oh Notation:
				-this is the worst possible runtime in asymptotic analysis, so 8n+5 is O(n) or 5n^4 + 2n^2 + 3n + 9 is O(n^4)
			-Big-Omega is the best possible runtime, big-Theta is the average
			-Comparatively, we check which algo is asymptotically better (O(n) is asymptotically better than O(nlogn)
			-Note though 10^100 * n is O(n), 10nlogn is O(nlogn), the second is still preferred despite being asymptotically worse, given that the first has such a huge constant
			-generally any algo running in O(nlogn) with reasonable coefficients is efficient, any exponential functions will almost never be considered efficient
			-ex of constant time operations is accessing an element in array A[k] or getting an arrays length, which is stored as a variable, both in O(1)
			-finding the max of an unsorted array is O(n) if you just go through one by one and compare (which is O(1) operation done n times)
			-Strings:
				-in Java, strings are immutable so adding to a string just creates a new string 
				-if a method takes an empty string then adds a char n times, its doing: 1+2+...+n times, which is O(n^2) because each addition takes more time as you are creating all those new strings
			-Three-Way Set Disjointness:
				-we have three sets, A, B, and C that are unique int[]
				-for(a: A)
					for(b:B)
						for(c:C)
							if all equal:
							O(1) operation
					-this is O(n^3), n*n*n for each for loop
				-instead do:
					for(a: A)
						for(b:B)
							if a==b:
								for(c:C)
									if a==c:
										O(1) operation
					-this is O(n^2) becasue there are quadractically many pairs (a,b) to consider,
					but if A and B are sets of distinct ints, there can be at most O(n) pairs with a == b, so C executs at most n times instead of n^2 times like before
			-Element Uniqueness Problem:
				-given an array of n elements and need to find if all elements are distinct
					-could just iterate through nested, which is O(n^2)
				-could sort the array first, then check for duplicates O(nlogn) + O(n) = O(nlogn), better than O(n^2)
			-Prefix Averages:
				-given a sequence x of n numbers, compute sequence a s.t. a.j is the average of elements x.0,...,x.j for j = 0,...,n-1
				-O(n^2) solution is to declare a new double array and have a running array count by iterating through the first array up until j, averaging, storing in new array for all j
				-O(n) solution is the same except use a total variable that is declared outside the for loops and just adds the newest val and averages that way
		-Simple Justification Techniques:
			-By example, includes counter examples
			-Contra Attack
				-Contrapositive is: Let a and b be integers, if ab is even, then a is even or b is even, so... If a is odd and b is odd, then ab is odd, so a = 2j+1 and b = 2k + 1, for ints j and k, then ab=4jk + 2k + 2j + 1 = 2(2jk + j + k) + 1, therefore ab is odd!
					-If a then b, contrapositive is if not b, then not a, and P or Q == not P and not Q
				-Contradiction: to prove P, assume P is false and show that produces a contradiction
			-Induction & Loop Invariants:
				-Induction:
					-to prove a predicate P(n) is true for all positive integers n
						-Base case: Show P(1) is true
						-Inductive Step: assume P(k) is true, then prove P(k+1) is also true (the assumption is called the inductive hypothesis)
					-ex:prove that for any positive int n, 2^n > n
						-Base case: n = 1
							-LHS = 2^1 = 2, RHS = 1, so LHS > RHS, true
						-Induction Step: (n>=1):
							-assume true for n = k for k >=1, ie 2^k > k
							-LHS = 2^(k+1) = 2^1 * 2^k = 2k (by inductive hypothesis) = k+k >= k + 1 = RHS, so LHS > RHS
				-Loop Invariants:
					-to prove a statement L about a loop is correct, define L in terms of a series of smaller statements, L0, L1,...Lk where:
						-L0, initial claim, is true before the loop
						-if Lj-1 is true before iteration j, then Lj will be true after iteration j
						-final claim Lk imples the desired statement L is true
					-ex: loop that goes through each array element to check if it is equal to a certain value, and if so, returns that index
						-L0: val (what we are seeing if data[j] is equal to), is not equal to any of the first j elements of data
							-true because j = 0 at the start
						-in iteration j, we compare element val to data[j], if equal, return j; if not equal, one more element is not equal to val and we increment j, making Lj claim true until j = n or we hit
	-CHAPTER 5 (Recursion):
		-Illustrative Recursion Examples:
			-factorial function: if n = 1, return 1, otherwise return n*factorial(n-1)
			-Binary Search:
				-used to efficiently find a target value within a sorted sequence of n elements in an array
				-if sequence is unsorted, use the standard approach where you loop and check all elements (linear or sequential search)
				-if sorted and indexable, use a more efficient search, need size and a midpoint = floor(low+high/2)
					-if target above mid, mid becomes the new low, find new mid and begin again
					-if below mid, high = mid, ""
					-if target is mid, we did it!
					-if low > high, then unsuccessful
			-Files:
				-Java.io.File:
					-new File(pathString) or new File(parentFile, childString) creates a new File instance
					-file.length() returns the disk usage in bytes for the OS entryrepresented by the File instance
					-file.isDirectory() returns T if the file is a directoy
					-file.list(), returns array of strings designtating the names of all entries within a given directory
		-Analyzing Recursive Algorithms:
			-binary search runs in O(logn) time for a sorted array w/ n elements (continually halving number of elements)
			-Computing Disk Space Usage:
				-the idea we can sometimes get a tighter bound on a series of operations by considering the cumuilative effect rather than assuming each achieves a worst case is called amortization
				-a file system is an implicit example of a tree data structure
					-disk usage algo in the textbook is really a manifestation of a more general algo known as a tree traversal
		-Further Examples:
			-if a recursive call starts at most one other, linear recursion:
				-summing all elements of an array recursively: if length is zero, return 0, else return sum(data, n-1) + data[n-1], runs in O(n)
				-reversing elements in an array runs in O(n/2) = O(n) if you swap high and low then inc/decrement each and call the function again
				-calculating exp. powers recursively also runs in O(n), if n == 0, return 1, else return n*power(x,n-1)
					-other way: if n = 0, return 1, if n is odd, return x*power(x,floor(n/2))^2, if even, dont multiply that by x
						-this is O(logn)
						-for odd: floor(n/2) = n-1/2 and (x^k)^2 = x^(n-1), so x^n = x*(x^k)^2
			-may call two others, binary recursion:
				-binarySum which sums from low to mid and from mid to high, recursion depth is 1+lg(n), using O(lg(n)), with 2n-1 calls, the runtime is O(n)
			-3+ calls, multiple recursion
		-Designing Recursive Algos:
			-Test for base cases (in factorial, its if n == 1, power n ==0, etc)
			-Recur if not a base case
			-Parameterizing:
				-binarySearch adds low and high to the method signature instead of just the array and the target value
		-Recursion Run Amok:
			-need to ensure implementing recursion does not drastically increase runtime
			-Fibonacci that returns n if n <= 1, or returns fib(n-2) + fib(n-1) is bad as it makes an exponential nuimber of calls in n!
				-to make efficient, make sure each invocation only makes one recursive call, fib(n-1) which would return [fib(n-1), fib(n-2)] from the text implementation, runs in O(n)
			-also need to ensure you do not create infinite recursion!
		-Eliminating Tail Recursion:
			-tail recursion is if any recursive call that is made from on context is the very last operation in that context
				-always linear recursion, by necessity
				-ex: return n*factorial(n-1) is NOT tail recursion because oan addtional multiplcation is performed after the call is completed
	-CHAPTER 6(Stacks,Queues, and Deques):
		-Stacks:
			-a collection of objects that are inserted and removed according to the principle of LIFO(last in, first out), so most recently addedis the first to get removed
			-ADT:
				-has push(e) (adds e to the top of the stack), pop() returns and removes the top element, top() just returns the top w/o removing, size() is num of elements, and isEmpty checks if its empty
					-in java.util.Stack class its push,pop,peek,size,and empty
						-do not use this though, its only there for historical reasons
				-ADT uses generics for the interface
			-Array Implementation:
				-bottom of the stack is data[0], keep an int that stores the top index, keep adding to data[k+1], pop data[k] and set it to 0
				-negative impact is that it has a fixed size, otherwise its very efficient and simple
					-all methods run in O(1) time with O(N) space usage
				-set to null when you pop to help with garbage collection
			-SLL Implementation:
				-adding is just making it the new head node, popping removes the head
			-Reversing an Array Using a Stack:
				-use two for loops, iterate through and push all elements, then iterate through again and pop all in the stack
		-Queues:
			-a cousin of the stack, this uses FIFO, or first in first out principle, so the element in the queue the longest is the first to be removed
				-think of a line or being on hold for customer service
			-ADT:
				-enqueue(e) adds element to the back of the queue, dequeue() removes and returns the first element from the queue (or null if empty), first() returns the first element w/o removing, size(), isEmpty()
			-Array Implementation:
				-add the normal way, keep track of the front index int val, moving forward one each time you dequeue, and wrap around from N-1 to 0 if needed! also store the size/number of stored elements
				-this also has O(1) runtimes and has a fixed length constraint
				-next index for addition is (front + size) % data.length
			-SLL Implementation:
				-all run in O(1) again, runs the same way except the head is now the oldest element
		-Double Ended Queues/Deques:
			-has both the ability to remove from the top and bottom on the stack/queue
			-ADT: addFirst(e), addLast(e), removeFirst/Last(), first(),last(), size(),isEmpty()
			-Can implement with a circular array or a DLL:
				-circular arrays wrap around from N-1 to 0 index
				-DLL:
					-O(1) for all

Module 1:
	-CHAPTER 1 (Java Primer):
		-Getting Started:
			-executable statements are placed in functions called methods that belong to some class definition
			-any set of statements b/w {} define a program "block"
			-name of a class,method, or variable in Java is called an identifier
				-must start with a letter and consists of lettes, numbers, and underscores
			-// or /*\n*\n*/ for inline or block comments.
			-Primitives:
				-boolean
				-char
				-byte (8-bit signed int)
				-short (16-bit signed int)
				-int
				-long (64-bit int)
				-float (32b)
				-double (64b)
		-Classes and Objects:
			-primary actors are objects, and each is an instance of a class, which serves as a type of the object and as a blueprint
			-critical members of a Java class:
				-instance variables or fields, represent data associated with an object of a class, must have a type
				-methods, blocks of code that can be called to perform actions, two types are accessor methods or update methods (doesn't and does change the instance variables, get vs set)
			-classes are known as reference types and a var of that type isa reference variable
				-ref var is capable of storing the location/mem address of an object from the declared class as well as null which is the lack of an object
			-a new object is created by using the new operator followed by a call to a constructor
				-new returns a reference to the newly created instance
			-creation of a new instance of class causes three events:
				-a new object is dynamically allocated in memory and all instance vars are initialized to default or given values (default is null for reference vars and 0 for base types)
				-constructor for the new object is called with the parameters specified, and the constructor may assign actual vaues to the instance vars
				-after the constructor returns, the new operator returns a reference to the newly created objet
			-use the dot . to access methods and instance variables associated with an object
			-method signature is the name and the number and types of its parameters
			-Modifiers:
				-access control modifiers control level of access/visibility
					-public designates that ALL classes may access the defined aspect
					-protected designates taht access to the defined aspect is only granted to the following:
						-classes that are subclasses or those that belong to the same package
					-private designates access only granted to code within the same class
				-static modifier:
					-variables: for global vars, its value is associated with the whole class
					-methods: it is associated with the class but not a particular instance of the class
				-abstract modifier:
					-its signature is provided, not any implementation
					-a class with one or more abstract methods must be declared abstract as it is incomplete
						-classes with no abstract methods can be declared abstract
				-final modifier:
					-the variable can NEVER be assigned a new value
			-Constructors:
				-cant be static,abstract, or final
				-name must be identical to the class
				-don't specify ANY return type, including void
				-Java usually provides a default constructor if there are no given parameters
		-Strings, Wrappers, Arrays, and Enum Types:
			-Strings:
				-Strings are 0+ chars, each of which can be referenced with an index (charAt(str))
				-can be added together in concatentation
				-Strings are immutable
				-StringBuilder class is mutable version of a string, has methods:
					-setCharAt(i,str)
					-insert(i,str_new)
					-append(new_str)
					-reverse()
					-toString()
			-Wrappers:
				-object version of all primitives, ie int x = 5 vs Integer x = new Integer(5)
				-int to Integer conversion iscalled boxing, unboxing is the opposite
			-Arrays:
				-declaring int[] x; OR int[] x = {1,2,3}; OR int[] x = new int[3]; (in this last case, all elements are set to the default)
			-Enum Types:
				-user defined variabl type ie:
					-public enum Day {MON, TUE, WED, THU, FRI, SAT, SUN};
					-Day today = Day.TUE;
		-Expressions:
			-Literals:
				-any constant vlaue that can be used in an assignment:
					-null
					-true/false
					-String Literal: sequence within ""
					-Char: \n. \', \t, etc.
			-Operators:
				-Arithmetic: +, -, *, /, %
				-String concat +
				-Increment and Decrement operators: ++, --
				-Logical: <,>,==,!=, &&, ||, etc.
				-Bitwise: ^,&,|, >>>, <<, etc
				-Assignment =
				-Compound Assignment: +=, *=, etc.
			-Type Conversions:
				-casting (type) var
					-int to double is widening, vice versa is narrowing
		-Control Flow:
			-if, else if, else
			-switch(x) {case a: case b: default:}, need a break after each case unless you want it to continue
			-Loops: for and while
				-for each: for (elementType name : container)
			-return, break, continue
		-Simple I/O:
			-print, println, objects in this just use o.toString()
			-input: Scanner -> new Scanner(System.in)
				-hasNext()
				-next()
				-hasNextType()
				-nextType()
				-hasNextLine()
				-nextLine()
				-findInLine(String s)
		-Software Development:
			-Three Steps:
				-Design
					-Define responsibilites, independence, behaviors
					-pseudocode
				-Coding
					-in an integrated development environment IDE
				-Testing and Debugging
	-CHAPTER 2 (Object Oriented Design):
		-Goals, Principles, and Patterns of OOD:
			-robustness(ready for any input), adaptability(can evolve over time), and reusability
			-basic principles are abstraction, encapsulation, and modularity
				-Abstraction:distill complicated system down to its most fundamental parts, using ADTs that specify what each operation does but not how
				-Encapsulation: different components of a software system should not reveal interal details of their implementations, allows parts to change w/o affecting other parts
				-Modularity: different components of a system are divided into separate functional units to greatly increase robustness since its easier to test this way.
		-Inheritance:
			-put tclasses into a hierarchy, houses are subsets of buildings but apartments are supersets of studios
			-a parent/super/base class exists wich a sub/child class extends
				-children can augment by adding new fields and new methods, can also override existing methods
			-use super() to access parent methods
			-Polymorphism
				-refers to ability of a reference variable to take different forms, ie Animal a can be declared and initialized to new Tiger(params)
					-a here is polymorphic
					-Java uses dynamic dispatch to determine at runtime to call the versio of the method that is most specific to the actual type, so if Animal and Tiger share a method, Java will chose the Tiger method
		-Interfaces and Abstract Classes:
			-Application Programming Interface(API) = interface
				-its a collection of method declarations with no data and no bodies, so all methods are always empty
				-classes can extend multiple classes, but can only implement one interface
			-abstract class is the in b/w of regular classes and interfaces
				-concrete classes are fully implemented
				-Java limited to single inheritance so classes can have at most one superclass, concrete or abstract
		-Exceptions:
			-exceptions are objects that can be "thrown" by code that encounters an unanticipated situation or by the JVM if - for ex - it runs out of memory.
			-code can also catch exceptions and another block of code will handle the issue
			-Java uses try-catch generally to handle exceptions
				-catch block deals with exceptions thrown in the try block
				-can have multiple catch blocks for different types of possible exceptions
				-finally blocks will be executed at the end regardless what happens
			-examples:
				-Catch:
					-catch (ArrayIndexOutOfBoundsException e) { handling...}
				-Throw:
					-throw new exceptionType(paratmeters);
					-this would be placed in code if you anticipate error, ie a check positive method that intakes an int, checks if a number is above 0, otherwise it could throw an IllegalArgumentException that states its not positive
			-Throwables are divided in Error and Exception
				-Errors: thrown only (typically) by the JVM and designate the most serious situations that are typically unrecoverable
					-ie a class file is corrupt
				-Exceptions: designate situations in which a running program might reasonably be able to recover
					-ie unable to open a data file
					-Exceptions are divided into checked and unchecked
						-Unchecked are all subtypes of runtime exceptions
							-ex: index OOB, illegal arg, null ptr
						-any exception type that is not part of the RuntimeException is a checked exception
							-ex: IOException, EOFException
							-all checked exceptions that might propogate upward from a method must be explicityl declared in its signature!
		-Casting and Generics:
			-Casting:
				-Widening Conversion:
					-occurs when a type T is converted into a wider type U
						-T & U are class types and U is a superclass of T
						-T & U are interface types and U is a superinterface of T
						-T is a class that implements interface U
						-explicit ex: CreditCard card = new PredatoryCreditCard(...)
							-U = new T()
				-Narrowing Conversion:
					-vice versa of widening (T to S):
						-T & S are class types a S is a subclass of T
						-S is a subinterface of T
						-S implements interface T
						-explicit ex: PredatoryCreditCard pc = (PredatoryCreditCard) card; //From above
				-Exceptions:
					-if object o is type T and we cast into S, provided o is referring to is actually type S, we are good
					-however, if o is not also of type S, then we get a ClassCastException, ex:
						Number n;
						Integer i;
						n = new Integer(3);
						i = (Integer) n; (LEGAL)
						n = new Double(3.14);
						i = (Integer) n; (ILLEGAL)
					-use try catch to avoid this!
					-use intsanceof, allows us to test whether it would work
						-objectReference instanceof referenceType returns T/F
						-ex:
							-n = new Double(3.14);
							-if (n instanceof Integer)
								i = (Integer) n;
							-no error will be thrown now, won't attempt third line!
			-Generics:
				-classes and methods that can operate on several data types are generic, they often avoid the need for explicit casts as well
				-generic frameworks allow us to define a class in terms of a set of "formal type parameters"
					-these can be used as the declared type for variables, params, and return vals
				-EX: if we wish to treat a pair of related vals as a single object, so they can be returned from a method, define a new class whose instances store both values
					-this is an OOD pattern called the "compoisiton design pattern"
				-<>, angled brackets, enclose the sequence of formal type params
					-when declaring a variable though, we need to specify the actual type params
						-so could be Pair<A,B> in the original code, but declaring must be, for ex:
							-Pair<String, Double> var;
					-instantiate the above as follows: var = new Pair<>("STRING", 12.34);
				-Arrays:
					-when instantiating arrays like this, it needs to be unparameterize:
						-Pair<String,Double> arr;
						-ILLEGAL: arr = new Pair<String,Double>[25];
						-LEGAL: arr = new Pair[25];
						-Legal: arr[0] = new Pair<>("STRING", 123.4);
				-Methods:
					-use "T" as the generic type so:
						-public static <T> void reverse(T[] data){ is an example signature
		-Nested Classes:
			-a nested class has its definition inside that of another class:
				-ex: public class CreditCard{
					private static class Transaction{}
					...
					Transaction[] history //logs all transactions for a statment
				}
				-CC is the outer class, trans is the nested class, the full name for it is CreditCard.Transaction
			-nested classes have their own visibility modifiers
				-private means only the outer class can use it
			-static can be applied, meaning its instances have no association witha ny specific instance of the outer class
				-in our ex, no specific transaction would be linked to on credit card
			-a nonstatic class is called an inner class in Java
				-can only be created within a nonstatic method of the outer class, each instance of an ionner class implicitly stores a reference to its outer instance using the syntax OuterName.this instead of just this
	-CHAPTER 3 (Fundamental Data Structures):
		-Using Arrays:
			-ex from textbook is storing game scores in an array, an object with a name and an int, sorted so high score is [0]
			-adding entries is important, by default all entries are null, process is:
				-update number of entries (easy, done in one line of code, unless there's a cap, then need an if statement)
				-place new entry in the appropriate location, shifting entries as needed
					-start from the lowest score and work way up, shifting entries as you go
			-removing you just shift all entries below to the left one, mark last entry as null
			-Sorting:
				-Insertion-Sort:
					-Input array A of n elements
					-Output array A w/ elems in nondecreasing order
					-Algo High Level:
						for k from 1 to n - 1
							insert A[k] at its proper location within A[0], A[1],...,A[k]
					-Java:
						n = A.length;
						for(int k = 1; k < n; k += 1) {
							char current = data[k];
							int j = k;
							while (j > 0 && data[j-1] > current) {
								data[j] = data[j-1];
								j -= 1;
							}
							data[j] = current;
						}
						-so start with the second element, grab that element, find the correct index for it by iterating through and moving any elements greater than current to the right of it.
			-Array methods and Random Numbers:
				-equals(A,B) returns true iff array A and B are equal (same number of elements and every corresponding pair of elements is equal(A[0]==B[0], A[n]==B[n]))
				-fill(A,x), stores x in every cell of A
				-copyOf(A,n) returns array of size n s.t. the first k elements of this array are copied from A, where k is the min of n and A.length, if n is bigger then the last few elements will be null or 0
				-copyOfRange(A,s,t) same as above but starts at A[s], ends at A[t-1]
				-toString(A) returns the String representation of A beginning with [ and ending with ]
				-sort(A) sorts A
				-binarySearch(A,x), searches the sorted array A for value x, returning its index
				-java has PRNG or pseudorandom number generators
					-nextBoolean() returns the next PR bool
					-nextDouble() "                  " double, between 0.0 and 1.0
					-nextInt() "" int
					-nextInt(n) "     " in range from 0 up to n, exclusive
					-setSeed(s), sets seed of PRNG to the long val of s
		-Singly Linked Lists:
			-Collection where each item or "node" stores two things, its value as well as pointer to the next element
			-the collection starts at the head, ends with the tail, which points to null next
			-adding to the head is simple, just create  a new node, have its next point the head and the head pointer now point to that new node
			-adding to the tail is the same
			-removing from the head or tail is just the opposite
			-add/remove from arbitrary points is more difficult, should just doubly linked lists for that
				-otherwise would need to traverse through the list
			-Implementation has the following methods:
				-size,isEmpty,first,last,addFirst(e),addLast(e),removeFirst()
		-Circularly Linked Lists:
			-essentially the next ptr in the tail points to the head, need to store those vals to be able to differentiate where it starts and ends
			-adds the rotate method which moves the first elem to the end of the list
		-Doubly Linked Lists:
			-this adds a second ptr that points to the previous element
			-use sentinels or dummy nodes that store no element values for the header and trailer for safety
				-header and trailer will now NEVER change, all insertions will be treated the same way as all nodes will be placed between two already exisiting nodes
			-insertion is creating a node, finding where it goes, making the prev and next ptrs correct and adjust the nodes that come before/after it so their next/prev ptrs point to it
			-deletion you just change node.prev.next to node.next and vice versa!
			-3.4.1 has an implementation that would be good to review!!
		-Equivalnce Testing:
			-for nonnull x, x.equals(null) should always return false
			-x.equals(x) should always return true
			-x.equals(y) and y.equals(x) should return the same val
			-if x.equals(y) and y.equals(z), then x.equals(z)
			-use .equals for non primitives/objects
			-Arrays:
				-== and .equals are identical for arrays, they need to be identical arrays
				-Arrays.equals(a,b) tests if every element is equal
				-if the elements are arrays, use Arrays.deepEquals(a,b) to avoid == comparisons
			-Linked Lists:
				-traverse both lists and .equals each element
		-Cloning Data Structures:
			-Shallow copy means if you change the copy's fields, you change the original
			-for arrays, use .clone() to create a separate array object that can be changed independently IF it stores primitives
				-if it stores objects, then the pointers within the array still all point to the same objects, need to use a deep clone to clone each element of that array
			-for linked lists:
				-clone the head and tail, and traverse through cloning each node and setting up those pointers correctly

	