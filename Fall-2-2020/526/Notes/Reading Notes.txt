Aidan Duffy
Boston University
METCS 526

Module 4:
	-CHAPTER 9 (Priority Queues):
		-
	-CHAPTER 10 (Maps & Hash Tables, skip 10.4):
		-

Module 3:
	-CHAPTER 7 (Lists):
		-The List ADT:
		-Array Lists:
		-Positional Lists:
		-Iterators:
		-Java Collections Framework:
		-Sorting Positional Lists:
		-Case Study: Maintaining Access Frequencies:
	-CHAPTER 8 (Trees):
		-General Trees:
		-Binary Trees:
		-Implementing Trees:
		-Tree Traversal Algos:


Module 2:
	-CHAPTER 4 (Algo Analysis):
		-The Seven Functions Used in this Book:
			-Constant function, so it always runs in the same amount of time, regardless of input size
			-
		-Asymptotic Analysis:
		-Simple Justification Techniques:
	-CHAPTER 5 (Recursion):
		-Illustrative Recursion Examples:
		-Analyzing Recursive Algorithms
		-Further Examples
		-Designing Recursive Algos:
		-Recursion Run Amok:
		-Eliminating Tail Recursion:
	-CHAPTER 6(Stacks,Queues, and Deques):
		-Stacks:
		-Queues:
		-Double Ended Queues/Deques:

Module 1:
	-CHAPTER 1 (Java Primer):
		-Getting Started:
			-executable statements are placed in functions called methods that belong to some class definition
			-any set of statements b/w {} define a program "block"
			-name of a class,method, or variable in Java is called an identifier
				-must start with a letter and consists of lettes, numbers, and underscores
			-// or /*\n*\n*/ for inline or block comments.
			-Primitives:
				-boolean
				-char
				-byte (8-bit signed int)
				-short (16-bit signed int)
				-int
				-long (64-bit int)
				-float (32b)
				-double (64b)
		-Classes and Objects:
			-primary actors are objects, and each is an instance of a class, which serves as a type of the object and as a blueprint
			-critical members of a Java class:
				-instance variables or fields, represent data associated with an object of a class, must have a type
				-methods, blocks of code that can be called to perform actions, two types are accessor methods or update methods (doesn't and does change the instance variables, get vs set)
			-classes are known as reference types and a var of that type isa reference variable
				-ref var is capable of storing the location/mem address of an object from the declared class as well as null which is the lack of an object
			-a new object is created by using the new operator followed by a call to a constructor
				-new returns a reference to the newly created instance
			-creation of a new instance of class causes three events:
				-a new object is dynamically allocated in memory and all instance vars are initialized to default or given values (default is null for reference vars and 0 for base types)
				-constructor for the new object is called with the parameters specified, and the constructor may assign actual vaues to the instance vars
				-after the constructor returns, the new operator returns a reference to the newly created objet
			-use the dot . to access methods and instance variables associated with an object
			-method signature is the name and the number and types of its parameters
			-Modifiers:
				-access control modifiers control level of access/visibility
					-public designates that ALL classes may access the defined aspect
					-protected designates taht access to the defined aspect is only granted to the following:
						-classes that are subclasses or those that belong to the same package
					-private designates access only granted to code within the same class
				-static modifier:
					-variables: for global vars, its value is associated with the whole class
					-methods: it is associated with the class but not a particular instance of the class
				-abstract modifier:
					-its signature is provided, not any implementation
					-a class with one or more abstract methods must be declared abstract as it is incomplete
						-classes with no abstract methods can be declared abstract
				-final modifier:
					-the variable can NEVER be assigned a new value
			-Constructors:
				-cant be static,abstract, or final
				-name must be identical to the class
				-don't specify ANY return type, including void
				-Java usually provides a default constructor if there are no given parameters
		-Strings, Wrappers, Arrays, and Enum Types:
			-Strings:
				-Strings are 0+ chars, each of which can be referenced with an index (charAt(str))
				-can be added together in concatentation
				-Strings are immutable
				-StringBuilder class is mutable version of a string, has methods:
					-setCharAt(i,str)
					-insert(i,str_new)
					-append(new_str)
					-reverse()
					-toString()
			-Wrappers:
				-object version of all primitives, ie int x = 5 vs Integer x = new Integer(5)
				-int to Integer conversion iscalled boxing, unboxing is the opposite
			-Arrays:
				-declaring int[] x; OR int[] x = {1,2,3}; OR int[] x = new int[3]; (in this last case, all elements are set to the default)
			-Enum Types:
				-user defined variabl type ie:
					-public enum Day {MON, TUE, WED, THU, FRI, SAT, SUN};
					-Day today = Day.TUE;
		-Expressions:
			-Literals:
				-any constant vlaue that can be used in an assignment:
					-null
					-true/false
					-String Literal: sequence within ""
					-Char: \n. \', \t, etc.
			-Operators:
				-Arithmetic: +, -, *, /, %
				-String concat +
				-Increment and Decrement operators: ++, --
				-Logical: <,>,==,!=, &&, ||, etc.
				-Bitwise: ^,&,|, >>>, <<, etc
				-Assignment =
				-Compound Assignment: +=, *=, etc.
			-Type Conversions:
				-casting (type) var
					-int to double is widening, vice versa is narrowing
		-Control Flow:
			-if, else if, else
			-switch(x) {case a: case b: default:}, need a break after each case unless you want it to continue
			-Loops: for and while
				-for each: for (elementType name : container)
			-return, break, continue
		-Simple I/O:
			-print, println, objects in this just use o.toString()
			-input: Scanner -> new Scanner(System.in)
				-hasNext()
				-next()
				-hasNextType()
				-nextType()
				-hasNextLine()
				-nextLine()
				-findInLine(String s)
		-Software Development:
			-Three Steps:
				-Design
					-Define responsibilites, independence, behaviors
					-pseudocode
				-Coding
					-in an integrated development environment IDE
				-Testing and Debugging
	-CHAPTER 2 (Object Oriented Design):
		-Goals, Principles, and Patterns of OOD:
			-robustness(ready for any input), adaptability(can evolve over time), and reusability
			-basic principles are abstraction, encapsulation, and modularity
				-Abstraction:distill complicated system down to its most fundamental parts, using ADTs that specify what each operation does but not how
				-Encapsulation: different components of a software system should not reveal interal details of their implementations, allows parts to change w/o affecting other parts
				-Modularity: different components of a system are divided into separate functional units to greatly increase robustness since its easier to test this way.
		-Inheritance:
			-put tclasses into a hierarchy, houses are subsets of buildings but apartments are supersets of studios
			-a parent/super/base class exists wich a sub/child class extends
				-children can augment by adding new fields and new methods, can also override existing methods
			-use super() to access parent methods
			-Polymorphism
				-refers to ability of a reference variable to take different forms, ie Animal a can be declared and initialized to new Tiger(params)
					-a here is polymorphic
					-Java uses dynamic dispatch to determine at runtime to call the versio of the method that is most specific to the actual type, so if Animal and Tiger share a method, Java will chose the Tiger method
		-Interfaces and Abstract Classes:
			-Application Programming Interface(API) = interface
				-its a collection of method declarations with no data and no bodies, so all methods are always empty
				-classes can extend multiple classes, but can only implement one interface
			-abstract class is the in b/w of regular classes and interfaces
				-concrete classes are fully implemented
				-Java limited to single inheritance so classes can have at most one superclass, concrete or abstract
		-Exceptions:
			-exceptions are objects that can be "thrown" by code that encounters an unanticipated situation or by the JVM if - for ex - it runs out of memory.
			-code can also catch exceptions and another block of code will handle the issue
			-Java uses try-catch generally to handle exceptions
				-catch block deals with exceptions thrown in the try block
				-can have multiple catch blocks for different types of possible exceptions
				-finally blocks will be executed at the end regardless what happens
			-examples:
				-Catch:
					-catch (ArrayIndexOutOfBoundsException e) { handling...}
				-Throw:
					-throw new exceptionType(paratmeters);
					-this would be placed in code if you anticipate error, ie a check positive method that intakes an int, checks if a number is above 0, otherwise it could throw an IllegalArgumentException that states its not positive
			-Throwables are divided in Error and Exception
				-Errors: thrown only (typically) by the JVM and designate the most serious situations that are typically unrecoverable
					-ie a class file is corrupt
				-Exceptions: designate situations in which a running program might reasonably be able to recover
					-ie unable to open a data file
					-Exceptions are divided into checked and unchecked
						-Unchecked are all subtypes of runtime exceptions
							-ex: index OOB, illegal arg, null ptr
						-any exception type that is not part of the RuntimeException is a checked exception
							-ex: IOException, EOFException
							-all checked exceptions that might propogate upward from a method must be explicityl declared in its signature!
		-Casting and Generics:
			-Casting:
				-Widening Conversion:
					-occurs when a type T is converted into a wider type U
						-T & U are class types and U is a superclass of T
						-T & U are interface types and U is a superinterface of T
						-T is a class that implements interface U
						-explicit ex: CreditCard card = new PredatoryCreditCard(...)
							-U = new T()
				-Narrowing Conversion:
					-vice versa of widening (T to S):
						-T & S are class types a S is a subclass of T
						-S is a subinterface of T
						-S implements interface T
						-explicit ex: PredatoryCreditCard pc = (PredatoryCreditCard) card; //From above
				-Exceptions:
					-if object o is type T and we cast into S, provided o is referring to is actually type S, we are good
					-however, if o is not also of type S, then we get a ClassCastException, ex:
						Number n;
						Integer i;
						n = new Integer(3);
						i = (Integer) n; (LEGAL)
						n = new Double(3.14);
						i = (Integer) n; (ILLEGAL)
					-use try catch to avoid this!
					-use intsanceof, allows us to test whether it would work
						-objectReference instanceof referenceType returns T/F
						-ex:
							-n = new Double(3.14);
							-if (n instanceof Integer)
								i = (Integer) n;
							-no error will be thrown now, won't attempt third line!
			-Generics:
				-classes and methods that can operate on several data types are generic, they often avoid the need for explicit casts as well
				-generic frameworks allow us to define a class in terms of a set of "formal type parameters"
					-these can be used as the declared type for variables, params, and return vals
				-EX: if we wish to treat a pair of related vals as a single object, so they can be returned from a method, define a new class whose instances store both values
					-this is an OOD pattern called the "compoisiton design pattern"
				-<>, angled brackets, enclose the sequence of formal type params
					-when declaring a variable though, we need to specify the actual type params
						-so could be Pair<A,B> in the original code, but declaring must be, for ex:
							-Pair<String, Double> var;
					-instantiate the above as follows: var = new Pair<>("STRING", 12.34);
				-Arrays:
					-when instantiating arrays like this, it needs to be unparameterize:
						-Pair<String,Double> arr;
						-ILLEGAL: arr = new Pair<String,Double>[25];
						-LEGAL: arr = new Pair[25];
						-Legal: arr[0] = new Pair<>("STRING", 123.4);
				-Methods:
					-use "T" as the generic type so:
						-public static <T> void reverse(T[] data){ is an example signature
		-Nested Classes:
			-a nested class has its definition inside that of another class:
				-ex: public class CreditCard{
					private static class Transaction{}
					...
					Transaction[] history //logs all transactions for a statment
				}
				-CC is the outer class, trans is the nested class, the full name for it is CreditCard.Transaction
			-nested classes have their own visibility modifiers
				-private means only the outer class can use it
			-static can be applied, meaning its instances have no association witha ny specific instance of the outer class
				-in our ex, no specific transaction would be linked to on credit card
			-a nonstatic class is called an inner class in Java
				-can only be created within a nonstatic method of the outer class, each instance of an ionner class implicitly stores a reference to its outer instance using the syntax OuterName.this instead of just this
	-CHAPTER 3 (Fundamental Data Structures):
		-Using Arrays:
			-ex from textbook is storing game scores in an array, an object with a name and an int, sorted so high score is [0]
			-adding entries is important, by default all entries are null, process is:
				-update number of entries (easy, done in one line of code, unless there's a cap, then need an if statement)
				-place new entry in the appropriate location, shifting entries as needed
					-start from the lowest score and work way up, shifting entries as you go
			-removing you just shift all entries below to the left one, mark last entry as null
			-Sorting:
				-Insertion-Sort:
					-Input array A of n elements
					-Output array A w/ elems in nondecreasing order
					-Algo High Level:
						for k from 1 to n - 1
							insert A[k] at its proper location within A[0], A[1],...,A[k]
					-Java:
						n = A.length;
						for(int k = 1; k < n; k += 1) {
							char current = data[k];
							int j = k;
							while (j > 0 && data[j-1] > current) {
								data[j] = data[j-1];
								j -= 1;
							}
							data[j] = current;
						}
						-so start with the second element, grab that element, find the correct index for it by iterating through and moving any elements greater than current to the right of it.
			-Array methods and Random Numbers:
				-equals(A,B) returns true iff array A and B are equal (same number of elements and every corresponding pair of elements is equal(A[0]==B[0], A[n]==B[n]))
				-fill(A,x), stores x in every cell of A
				-copyOf(A,n) returns array of size n s.t. the first k elements of this array are copied from A, where k is the min of n and A.length, if n is bigger then the last few elements will be null or 0
				-copyOfRange(A,s,t) same as above but starts at A[s], ends at A[t-1]
				-toString(A) returns the String representation of A beginning with [ and ending with ]
				-sort(A) sorts A
				-binarySearch(A,x), searches the sorted array A for value x, returning its index
				-java has PRNG or pseudorandom number generators
					-nextBoolean() returns the next PR bool
					-nextDouble() "                  " double, between 0.0 and 1.0
					-nextInt() "" int
					-nextInt(n) "     " in range from 0 up to n, exclusive
					-setSeed(s), sets seed of PRNG to the long val of s
		-Singly Linked Lists:
			-Collection where each item or "node" stores two things, its value as well as pointer to the next element
			-the collection starts at the head, ends with the tail, which points to null next
			-adding to the head is simple, just create  a new node, have its next point the head and the head pointer now point to that new node
			-adding to the tail is the same
			-removing from the head or tail is just the opposite
			-add/remove from arbitrary points is more difficult, should just doubly linked lists for that
				-otherwise would need to traverse through the list
			-Implementation has the following methods:
				-size,isEmpty,first,last,addFirst(e),addLast(e),removeFirst()
		-Circularly Linked Lists:
			-essentially the next ptr in the tail points to the head, need to store those vals to be able to differentiate where it starts and ends
			-adds the rotate method which moves the first elem to the end of the list
		-Doubly Linked Lists:
			-this adds a second ptr that points to the previous element
			-use sentinels or dummy nodes that store no element values for the header and trailer for safety
				-header and trailer will now NEVER change, all insertions will be treated the same way as all nodes will be placed between two already exisiting nodes
			-insertion is creating a node, finding where it goes, making the prev and next ptrs correct and adjust the nodes that come before/after it so their next/prev ptrs point to it
			-deletion you just change node.prev.next to node.next and vice versa!
			-3.4.1 has an implementation that would be good to review!!
		-Equivalnce Testing:
			-for nonnull x, x.equals(null) should always return false
			-x.equals(x) should always return true
			-x.equals(y) and y.equals(x) should return the same val
			-if x.equals(y) and y.equals(z), then x.equals(z)
			-use .equals for non primitives/objects
			-Arrays:
				-== and .equals are identical for arrays, they need to be identical arrays
				-Arrays.equals(a,b) tests if every element is equal
				-if the elements are arrays, use Arrays.deepEquals(a,b) to avoid == comparisons
			-Linked Lists:
				-traverse both lists and .equals each element
		-Cloning Data Structures:
			-Shallow copy means if you change the copy's fields, you change the original
			-for arrays, use .clone() to create a separate array object that can be changed independently IF it stores primitives
				-if it stores objects, then the pointers within the array still all point to the same objects, need to use a deep clone to clone each element of that array
			-for linked lists:
				-clone the head and tail, and traverse through cloning each node and setting up those pointers correctly

	