Aidan Duffy
Boston University
METCS 526

Module 4:
	-CHAPTER 9 (Priority Queues):
		-
	-CHAPTER 10 (Maps & Hash Tables, skip 10.4):
		-

Module 3:
	-CHAPTER 7 (Lists):
		-The List ADT:
		-Array Lists:
		-Positional Lists:
		-Iterators:
		-Java Collections Framework:
		-Sorting Positional Lists:
		-Case Study: Maintaining Access Frequencies:
	-CHAPTER 8 (Trees):
		-General Trees:
		-Binary Trees:
		-Implementing Trees:
		-Tree Traversal Algos:


Module 2:
	-CHAPTER 4 (Algo Analysis):
		-The Seven Functions Used in this Book:
			-Constant function, so it always runs in the same amount of time, regardless of input size
			-Logarithm Function, runs in log(n) time, usually log base 2
			-Linear function, runs in n time, ie comparing some num to each element of array sized n
			-N-Log-N Function, runs in n*log(n) time
			-Quadratic, runs in x^2 time, often pops up with nested loops
				-if the first iteration of the loop uses 1 op, the second uses 2 ops, up to n operations, then that happens n times
			-Cubic/Other polynomials runs in n^3 or n^a time, for polys, just use the biggest power for the big-Oh notation
			-Exponential function runs in a^n time, where input size is the power
		-Asymptotic Analysis:
			-Big-Oh Notation:
				-this is the worst possible runtime in asymptotic analysis, so 8n+5 is O(n) or 5n^4 + 2n^2 + 3n + 9 is O(n^4)
			-Big-Omega is the best possible runtime, big-Theta is the average
			-Comparatively, we check which algo is asymptotically better (O(n) is asymptotically better than O(nlogn)
			-Note though 10^100 * n is O(n), 10nlogn is O(nlogn), the second is still preferred despite being asymptotically worse, given that the first has such a huge constant
			-generally any algo running in O(nlogn) with reasonable coefficients is efficient, any exponential functions will almost never be considered efficient
			-ex of constant time operations is accessing an element in array A[k] or getting an arrays length, which is stored as a variable, both in O(1)
			-finding the max of an unsorted array is O(n) if you just go through one by one and compare (which is O(1) operation done n times)
			-Strings:
				-in Java, strings are immutable so adding to a string just creates a new string 
				-if a method takes an empty string then adds a char n times, its doing: 1+2+...+n times, which is O(n^2) because each addition takes more time as you are creating all those new strings
			-Three-Way Set Disjointness:
				-we have three sets, A, B, and C that are unique int[]
				-for(a: A)
					for(b:B)
						for(c:C)
							if all equal:
							O(1) operation
					-this is O(n^3), n*n*n for each for loop
				-instead do:
					for(a: A)
						for(b:B)
							if a==b:
								for(c:C)
									if a==c:
										O(1) operation
					-this is O(n^2) becasue there are quadractically many pairs (a,b) to consider,
					but if A and B are sets of distinct ints, there can be at most O(n) pairs with a == b, so C executs at most n times instead of n^2 times like before
			-Element Uniqueness Problem:
				-given an array of n elements and need to find if all elements are distinct
					-could just iterate through nested, which is O(n^2)
				-could sort the array first, then check for duplicates O(nlogn) + O(n) = O(nlogn), better than O(n^2)
			-Prefix Averages:
				-given a sequence x of n numbers, compute sequence a s.t. a.j is the average of elements x.0,...,x.j for j = 0,...,n-1
				-O(n^2) solution is to declare a new double array and have a running array count by iterating through the first array up until j, averaging, storing in new array for all j
				-O(n) solution is the same except use a total variable that is declared outside the for loops and just adds the newest val and averages that way
		-Simple Justification Techniques:
			-By example, includes counter examples
			-Contra Attack
				-Contrapositive is: Let a and b be integers, if ab is even, then a is even or b is even, so... If a is odd and b is odd, then ab is odd, so a = 2j+1 and b = 2k + 1, for ints j and k, then ab=4jk + 2k + 2j + 1 = 2(2jk + j + k) + 1, therefore ab is odd!
					-If a then b, contrapositive is if not b, then not a, and P or Q == not P and not Q
				-Contradiction: to prove P, assume P is false and show that produces a contradiction
			-Induction & Loop Invariants:
				-Induction:
					-to prove a predicate P(n) is true for all positive integers n
						-Base case: Show P(1) is true
						-Inductive Step: assume P(k) is true, then prove P(k+1) is also true (the assumption is called the inductive hypothesis)
					-ex:prove that for any positive int n, 2^n > n
						-Base case: n = 1
							-LHS = 2^1 = 2, RHS = 1, so LHS > RHS, true
						-Induction Step: (n>=1):
							-assume true for n = k for k >=1, ie 2^k > k
							-LHS = 2^(k+1) = 2^1 * 2^k = 2k (by inductive hypothesis) = k+k >= k + 1 = RHS, so LHS > RHS
				-Loop Invariants:
					-to prove a statement L about a loop is correct, define L in terms of a series of smaller statements, L0, L1,...Lk where:
						-L0, initial claim, is true before the loop
						-if Lj-1 is true before iteration j, then Lj will be true after iteration j
						-final claim Lk imples the desired statement L is true
					-ex: loop that goes through each array element to check if it is equal to a certain value, and if so, returns that index
						-L0: val (what we are seeing if data[j] is equal to), is not equal to any of the first j elements of data
							-true because j = 0 at the start
						-in iteration j, we compare element val to data[j], if equal, return j; if not equal, one more element is not equal to val and we increment j, making Lj claim true until j = n or we hit
	-CHAPTER 5 (Recursion):
		-Illustrative Recursion Examples:
			-factorial function: if n = 1, return 1, otherwise return n*factorial(n-1)
			-Binary Search:
				-used to efficiently find a target value within a sorted sequence of n elements in an array
				-if sequence is unsorted, use the standard approach where you loop and check all elements (linear or sequential search)
				-if sorted and indexable, use a more efficient search, need size and a midpoint = floor(low+high/2)
					-if target above mid, mid becomes the new low, find new mid and begin again
					-if below mid, high = mid, ""
					-if target is mid, we did it!
					-if low > high, then unsuccessful
			-Files:
				-Java.io.File:
					-new File(pathString) or new File(parentFile, childString) creates a new File instance
					-file.length() returns the disk usage in bytes for the OS entryrepresented by the File instance
					-file.isDirectory() returns T if the file is a directoy
					-file.list(), returns array of strings designtating the names of all entries within a given directory
		-Analyzing Recursive Algorithms:
			-binary search runs in O(logn) time for a sorted array w/ n elements (continually halving number of elements)
			-Computing Disk Space Usage:
				-the idea we can sometimes get a tighter bound on a series of operations by considering the cumuilative effect rather than assuming each achieves a worst case is called amortization
				-a file system is an implicit example of a tree data structure
					-disk usage algo in the textbook is really a manifestation of a more general algo known as a tree traversal
		-Further Examples:
			-if a recursive call starts at most one other, linear recursion:
				-summing all elements of an array recursively: if length is zero, return 0, else return sum(data, n-1) + data[n-1], runs in O(n)
				-reversing elements in an array runs in O(n/2) = O(n) if you swap high and low then inc/decrement each and call the function again
				-calculating exp. powers recursively also runs in O(n), if n == 0, return 1, else return n*power(x,n-1)
					-other way: if n = 0, return 1, if n is odd, return x*power(x,floor(n/2))^2, if even, dont multiply that by x
						-this is O(logn)
						-for odd: floor(n/2) = n-1/2 and (x^k)^2 = x^(n-1), so x^n = x*(x^k)^2
			-may call two others, binary recursion:
				-binarySum which sums from low to mid and from mid to high, recursion depth is 1+lg(n), using O(lg(n)), with 2n-1 calls, the runtime is O(n)
			-3+ calls, multiple recursion
		-Designing Recursive Algos:
			-Test for base cases (in factorial, its if n == 1, power n ==0, etc)
			-Recur if not a base case
			-Parameterizing:
				-binarySearch adds low and high to the method signature instead of just the array and the target value
		-Recursion Run Amok:
			-need to ensure implementing recursion does not drastically increase runtime
			-Fibonacci that returns n if n <= 1, or returns fib(n-2) + fib(n-1) is bad as it makes an exponential nuimber of calls in n!
				-to make efficient, make sure each invocation only makes one recursive call, fib(n-1) which would return [fib(n-1), fib(n-2)] from the text implementation, runs in O(n)
			-also need to ensure you do not create infinite recursion!
		-Eliminating Tail Recursion:
			-tail recursion is if any recursive call that is made from on context is the very last operation in that context
				-always linear recursion, by necessity
				-ex: return n*factorial(n-1) is NOT tail recursion because oan addtional multiplcation is performed after the call is completed
	-CHAPTER 6(Stacks,Queues, and Deques):
		-Stacks:
		-Queues:
		-Double Ended Queues/Deques:

Module 1:
	-CHAPTER 1 (Java Primer):
		-Getting Started:
			-executable statements are placed in functions called methods that belong to some class definition
			-any set of statements b/w {} define a program "block"
			-name of a class,method, or variable in Java is called an identifier
				-must start with a letter and consists of lettes, numbers, and underscores
			-// or /*\n*\n*/ for inline or block comments.
			-Primitives:
				-boolean
				-char
				-byte (8-bit signed int)
				-short (16-bit signed int)
				-int
				-long (64-bit int)
				-float (32b)
				-double (64b)
		-Classes and Objects:
			-primary actors are objects, and each is an instance of a class, which serves as a type of the object and as a blueprint
			-critical members of a Java class:
				-instance variables or fields, represent data associated with an object of a class, must have a type
				-methods, blocks of code that can be called to perform actions, two types are accessor methods or update methods (doesn't and does change the instance variables, get vs set)
			-classes are known as reference types and a var of that type isa reference variable
				-ref var is capable of storing the location/mem address of an object from the declared class as well as null which is the lack of an object
			-a new object is created by using the new operator followed by a call to a constructor
				-new returns a reference to the newly created instance
			-creation of a new instance of class causes three events:
				-a new object is dynamically allocated in memory and all instance vars are initialized to default or given values (default is null for reference vars and 0 for base types)
				-constructor for the new object is called with the parameters specified, and the constructor may assign actual vaues to the instance vars
				-after the constructor returns, the new operator returns a reference to the newly created objet
			-use the dot . to access methods and instance variables associated with an object
			-method signature is the name and the number and types of its parameters
			-Modifiers:
				-access control modifiers control level of access/visibility
					-public designates that ALL classes may access the defined aspect
					-protected designates taht access to the defined aspect is only granted to the following:
						-classes that are subclasses or those that belong to the same package
					-private designates access only granted to code within the same class
				-static modifier:
					-variables: for global vars, its value is associated with the whole class
					-methods: it is associated with the class but not a particular instance of the class
				-abstract modifier:
					-its signature is provided, not any implementation
					-a class with one or more abstract methods must be declared abstract as it is incomplete
						-classes with no abstract methods can be declared abstract
				-final modifier:
					-the variable can NEVER be assigned a new value
			-Constructors:
				-cant be static,abstract, or final
				-name must be identical to the class
				-don't specify ANY return type, including void
				-Java usually provides a default constructor if there are no given parameters
		-Strings, Wrappers, Arrays, and Enum Types:
			-Strings:
				-Strings are 0+ chars, each of which can be referenced with an index (charAt(str))
				-can be added together in concatentation
				-Strings are immutable
				-StringBuilder class is mutable version of a string, has methods:
					-setCharAt(i,str)
					-insert(i,str_new)
					-append(new_str)
					-reverse()
					-toString()
			-Wrappers:
				-object version of all primitives, ie int x = 5 vs Integer x = new Integer(5)
				-int to Integer conversion iscalled boxing, unboxing is the opposite
			-Arrays:
				-declaring int[] x; OR int[] x = {1,2,3}; OR int[] x = new int[3]; (in this last case, all elements are set to the default)
			-Enum Types:
				-user defined variabl type ie:
					-public enum Day {MON, TUE, WED, THU, FRI, SAT, SUN};
					-Day today = Day.TUE;
		-Expressions:
			-Literals:
				-any constant vlaue that can be used in an assignment:
					-null
					-true/false
					-String Literal: sequence within ""
					-Char: \n. \', \t, etc.
			-Operators:
				-Arithmetic: +, -, *, /, %
				-String concat +
				-Increment and Decrement operators: ++, --
				-Logical: <,>,==,!=, &&, ||, etc.
				-Bitwise: ^,&,|, >>>, <<, etc
				-Assignment =
				-Compound Assignment: +=, *=, etc.
			-Type Conversions:
				-casting (type) var
					-int to double is widening, vice versa is narrowing
		-Control Flow:
			-if, else if, else
			-switch(x) {case a: case b: default:}, need a break after each case unless you want it to continue
			-Loops: for and while
				-for each: for (elementType name : container)
			-return, break, continue
		-Simple I/O:
			-print, println, objects in this just use o.toString()
			-input: Scanner -> new Scanner(System.in)
				-hasNext()
				-next()
				-hasNextType()
				-nextType()
				-hasNextLine()
				-nextLine()
				-findInLine(String s)
		-Software Development:
			-Three Steps:
				-Design
					-Define responsibilites, independence, behaviors
					-pseudocode
				-Coding
					-in an integrated development environment IDE
				-Testing and Debugging
	-CHAPTER 2 (Object Oriented Design):
		-Goals, Principles, and Patterns of OOD:
			-robustness(ready for any input), adaptability(can evolve over time), and reusability
			-basic principles are abstraction, encapsulation, and modularity
				-Abstraction:distill complicated system down to its most fundamental parts, using ADTs that specify what each operation does but not how
				-Encapsulation: different components of a software system should not reveal interal details of their implementations, allows parts to change w/o affecting other parts
				-Modularity: different components of a system are divided into separate functional units to greatly increase robustness since its easier to test this way.
		-Inheritance:
			-put tclasses into a hierarchy, houses are subsets of buildings but apartments are supersets of studios
			-a parent/super/base class exists wich a sub/child class extends
				-children can augment by adding new fields and new methods, can also override existing methods
			-use super() to access parent methods
			-Polymorphism
				-refers to ability of a reference variable to take different forms, ie Animal a can be declared and initialized to new Tiger(params)
					-a here is polymorphic
					-Java uses dynamic dispatch to determine at runtime to call the versio of the method that is most specific to the actual type, so if Animal and Tiger share a method, Java will chose the Tiger method
		-Interfaces and Abstract Classes:
			-Application Programming Interface(API) = interface
				-its a collection of method declarations with no data and no bodies, so all methods are always empty
				-classes can extend multiple classes, but can only implement one interface
			-abstract class is the in b/w of regular classes and interfaces
				-concrete classes are fully implemented
				-Java limited to single inheritance so classes can have at most one superclass, concrete or abstract
		-Exceptions:
			-exceptions are objects that can be "thrown" by code that encounters an unanticipated situation or by the JVM if - for ex - it runs out of memory.
			-code can also catch exceptions and another block of code will handle the issue
			-Java uses try-catch generally to handle exceptions
				-catch block deals with exceptions thrown in the try block
				-can have multiple catch blocks for different types of possible exceptions
				-finally blocks will be executed at the end regardless what happens
			-examples:
				-Catch:
					-catch (ArrayIndexOutOfBoundsException e) { handling...}
				-Throw:
					-throw new exceptionType(paratmeters);
					-this would be placed in code if you anticipate error, ie a check positive method that intakes an int, checks if a number is above 0, otherwise it could throw an IllegalArgumentException that states its not positive
			-Throwables are divided in Error and Exception
				-Errors: thrown only (typically) by the JVM and designate the most serious situations that are typically unrecoverable
					-ie a class file is corrupt
				-Exceptions: designate situations in which a running program might reasonably be able to recover
					-ie unable to open a data file
					-Exceptions are divided into checked and unchecked
						-Unchecked are all subtypes of runtime exceptions
							-ex: index OOB, illegal arg, null ptr
						-any exception type that is not part of the RuntimeException is a checked exception
							-ex: IOException, EOFException
							-all checked exceptions that might propogate upward from a method must be explicityl declared in its signature!
		-Casting and Generics:
			-Casting:
				-Widening Conversion:
					-occurs when a type T is converted into a wider type U
						-T & U are class types and U is a superclass of T
						-T & U are interface types and U is a superinterface of T
						-T is a class that implements interface U
						-explicit ex: CreditCard card = new PredatoryCreditCard(...)
							-U = new T()
				-Narrowing Conversion:
					-vice versa of widening (T to S):
						-T & S are class types a S is a subclass of T
						-S is a subinterface of T
						-S implements interface T
						-explicit ex: PredatoryCreditCard pc = (PredatoryCreditCard) card; //From above
				-Exceptions:
					-if object o is type T and we cast into S, provided o is referring to is actually type S, we are good
					-however, if o is not also of type S, then we get a ClassCastException, ex:
						Number n;
						Integer i;
						n = new Integer(3);
						i = (Integer) n; (LEGAL)
						n = new Double(3.14);
						i = (Integer) n; (ILLEGAL)
					-use try catch to avoid this!
					-use intsanceof, allows us to test whether it would work
						-objectReference instanceof referenceType returns T/F
						-ex:
							-n = new Double(3.14);
							-if (n instanceof Integer)
								i = (Integer) n;
							-no error will be thrown now, won't attempt third line!
			-Generics:
				-classes and methods that can operate on several data types are generic, they often avoid the need for explicit casts as well
				-generic frameworks allow us to define a class in terms of a set of "formal type parameters"
					-these can be used as the declared type for variables, params, and return vals
				-EX: if we wish to treat a pair of related vals as a single object, so they can be returned from a method, define a new class whose instances store both values
					-this is an OOD pattern called the "compoisiton design pattern"
				-<>, angled brackets, enclose the sequence of formal type params
					-when declaring a variable though, we need to specify the actual type params
						-so could be Pair<A,B> in the original code, but declaring must be, for ex:
							-Pair<String, Double> var;
					-instantiate the above as follows: var = new Pair<>("STRING", 12.34);
				-Arrays:
					-when instantiating arrays like this, it needs to be unparameterize:
						-Pair<String,Double> arr;
						-ILLEGAL: arr = new Pair<String,Double>[25];
						-LEGAL: arr = new Pair[25];
						-Legal: arr[0] = new Pair<>("STRING", 123.4);
				-Methods:
					-use "T" as the generic type so:
						-public static <T> void reverse(T[] data){ is an example signature
		-Nested Classes:
			-a nested class has its definition inside that of another class:
				-ex: public class CreditCard{
					private static class Transaction{}
					...
					Transaction[] history //logs all transactions for a statment
				}
				-CC is the outer class, trans is the nested class, the full name for it is CreditCard.Transaction
			-nested classes have their own visibility modifiers
				-private means only the outer class can use it
			-static can be applied, meaning its instances have no association witha ny specific instance of the outer class
				-in our ex, no specific transaction would be linked to on credit card
			-a nonstatic class is called an inner class in Java
				-can only be created within a nonstatic method of the outer class, each instance of an ionner class implicitly stores a reference to its outer instance using the syntax OuterName.this instead of just this
	-CHAPTER 3 (Fundamental Data Structures):
		-Using Arrays:
			-ex from textbook is storing game scores in an array, an object with a name and an int, sorted so high score is [0]
			-adding entries is important, by default all entries are null, process is:
				-update number of entries (easy, done in one line of code, unless there's a cap, then need an if statement)
				-place new entry in the appropriate location, shifting entries as needed
					-start from the lowest score and work way up, shifting entries as you go
			-removing you just shift all entries below to the left one, mark last entry as null
			-Sorting:
				-Insertion-Sort:
					-Input array A of n elements
					-Output array A w/ elems in nondecreasing order
					-Algo High Level:
						for k from 1 to n - 1
							insert A[k] at its proper location within A[0], A[1],...,A[k]
					-Java:
						n = A.length;
						for(int k = 1; k < n; k += 1) {
							char current = data[k];
							int j = k;
							while (j > 0 && data[j-1] > current) {
								data[j] = data[j-1];
								j -= 1;
							}
							data[j] = current;
						}
						-so start with the second element, grab that element, find the correct index for it by iterating through and moving any elements greater than current to the right of it.
			-Array methods and Random Numbers:
				-equals(A,B) returns true iff array A and B are equal (same number of elements and every corresponding pair of elements is equal(A[0]==B[0], A[n]==B[n]))
				-fill(A,x), stores x in every cell of A
				-copyOf(A,n) returns array of size n s.t. the first k elements of this array are copied from A, where k is the min of n and A.length, if n is bigger then the last few elements will be null or 0
				-copyOfRange(A,s,t) same as above but starts at A[s], ends at A[t-1]
				-toString(A) returns the String representation of A beginning with [ and ending with ]
				-sort(A) sorts A
				-binarySearch(A,x), searches the sorted array A for value x, returning its index
				-java has PRNG or pseudorandom number generators
					-nextBoolean() returns the next PR bool
					-nextDouble() "                  " double, between 0.0 and 1.0
					-nextInt() "" int
					-nextInt(n) "     " in range from 0 up to n, exclusive
					-setSeed(s), sets seed of PRNG to the long val of s
		-Singly Linked Lists:
			-Collection where each item or "node" stores two things, its value as well as pointer to the next element
			-the collection starts at the head, ends with the tail, which points to null next
			-adding to the head is simple, just create  a new node, have its next point the head and the head pointer now point to that new node
			-adding to the tail is the same
			-removing from the head or tail is just the opposite
			-add/remove from arbitrary points is more difficult, should just doubly linked lists for that
				-otherwise would need to traverse through the list
			-Implementation has the following methods:
				-size,isEmpty,first,last,addFirst(e),addLast(e),removeFirst()
		-Circularly Linked Lists:
			-essentially the next ptr in the tail points to the head, need to store those vals to be able to differentiate where it starts and ends
			-adds the rotate method which moves the first elem to the end of the list
		-Doubly Linked Lists:
			-this adds a second ptr that points to the previous element
			-use sentinels or dummy nodes that store no element values for the header and trailer for safety
				-header and trailer will now NEVER change, all insertions will be treated the same way as all nodes will be placed between two already exisiting nodes
			-insertion is creating a node, finding where it goes, making the prev and next ptrs correct and adjust the nodes that come before/after it so their next/prev ptrs point to it
			-deletion you just change node.prev.next to node.next and vice versa!
			-3.4.1 has an implementation that would be good to review!!
		-Equivalnce Testing:
			-for nonnull x, x.equals(null) should always return false
			-x.equals(x) should always return true
			-x.equals(y) and y.equals(x) should return the same val
			-if x.equals(y) and y.equals(z), then x.equals(z)
			-use .equals for non primitives/objects
			-Arrays:
				-== and .equals are identical for arrays, they need to be identical arrays
				-Arrays.equals(a,b) tests if every element is equal
				-if the elements are arrays, use Arrays.deepEquals(a,b) to avoid == comparisons
			-Linked Lists:
				-traverse both lists and .equals each element
		-Cloning Data Structures:
			-Shallow copy means if you change the copy's fields, you change the original
			-for arrays, use .clone() to create a separate array object that can be changed independently IF it stores primitives
				-if it stores objects, then the pointers within the array still all point to the same objects, need to use a deep clone to clone each element of that array
			-for linked lists:
				-clone the head and tail, and traverse through cloning each node and setting up those pointers correctly

	